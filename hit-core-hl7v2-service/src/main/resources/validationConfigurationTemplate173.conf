# reference.conf

report {

  # Detections classifications
  classification {
    error         = "Error"
    warning       = "Warning"
    alert         = "Alert"
    high-alert    = "High Alert"
    informational = "Informational"
    affirmative   = "Affirmative"
    spec-error    = "Specification Error"
  }

  # Detections categories
  category {

    # Structure
    usage = "Usage"
    o-usage = "O-Usage"
    cardinality = "Cardinality"
    length = "Length"
    length-spec-error = "Length Spec Error"
    format = "Format"
    extra = "Extra"
    unexpected = "Unexpected"
    invalid = "Invalid Content"
    unescaped = "Unescaped Separator"
    unresolved-field = "Unresolved Field Model"
    constant-value = "Constant Value"
    constant-value-spec-error = "Constant Value Spec Error"
    dynamic-mapping-match = "Dynamic Mapping Match"

    # Constraints
    constraint-failure = "Constraint Failure"
    coconstraint-failure = "CoConstraint Failure"
    content-failure = "Content Failure"
    constraint-success = "Constraint Success"
    coconstraint-success = "CoConstraint Success"
    content-success = "Content Success"
    constraint-spec-error = "Constraint Spec Error"
    content-spec-error = "Content Spec Error"
    co-constraint = "Co-Constraint"
    co-constraint-spec-error = "Co-Constraint Spec Error"

    # Predicate
    predicate-failure = "Predicate Failure"
    predicate-success = "Predicate Success"
    predicate-spec-error = "Predicate Spec Error"
    predicate-usage-selection = "Predicate Usage Selection"
    predicate-path-occurrence = "Predicate Path Occurrence"

    # Slicing
    slicing-spec-error = "Slicing Spec Error"
    slicing = "Slicing"

    # Value Sets
    ubs	= "Undetermined Binding Strength"
    evs = "EVS"
    pvs = "PVS"
    rvs = "RVS"
    code-not-found = "Code Not Found"
    vs-not-found = "VS Not Found"
    empty-vs = "Empty VS"
    proxied-valueset = "Proxied Value Set"
    vs-no-validation = "Excluded From Validation"
    coded-element = "Coded Element"
    coded-element-xor = "Coded Element"
    binding-location = "Binding Location"
    vs-spec-error = "Value Set Binding Spec Error"
    no-code-usage = "No Code Usage"
    dynamic-vs = "Dynamic Value Set"
    duplicate-code = "Duplicate Code"
    vs-0396 = "ValueSet 0396"
    external-valueset-validation-disabled = "External Value Set Validation Disabled"
    external-vs-spec-error = "External Value Set Spec Error"

    # Single Code
    single-code-failure = "Single Code Failure"
    single-code-success = "Single Code Success"
  }

  ####################################################################################
  ###                         Structure based detections                           ###
  ####################################################################################

  # This detection is raised when an element with R usage is not populated
  # Template parameters are:
  # 1) Target element
  # 2) (Optional) the context of this usage - for example when the usage is coming from a conditional
  r-usage {
    template = "The required %s is missing%s"
    category = ${report.category.usage}
    classification = ${report.classification.error}
    documentation = "This detection is raised when an element with R usage is not populated"
  }

  # This detection is raised when an element with X usage is populated
  # Template parameters are:
  # 1) Target element
  # 2) (Optional) the context of this usage - for example when the usage is coming from a conditional
  x-usage {
    template = "The %s is present whereas it is an unsupported element (Usage = X)%s"
    category = ${report.category.usage}
    classification = ${report.classification.error}
    documentation = "This detection is raised when an element with X usage is populated"
  }

  # This detection is raised when an element with W usage is populated
  # Template parameters are:
  # 1) Target element
  # 2) (Optional) the context of this usage - for example when the usage is coming from a conditional
  w-usage {
    template = "The %s is present whereas it is a withdrawn element (Usage = W)%s"
    category = ${report.category.usage}
    classification = ${report.classification.error}
    documentation = "This detection is raised when an element with W usage is populated"
  }

  # This detection is raised when an element with RE usage is not populated
  # Template parameters are:
  # 1) Target element
  # 2) (Optional) the context of this usage - for example when the usage is coming from a conditional
  re-usage {
    template = "%s is missing. Depending on the use case and data availability it may be appropriate to value this element (Usage is "RE", Required, but may be Empty).%s"
    category = ${report.category.usage}
    classification = ${report.classification.warning}
    documentation = "This detection is raised when an element with RE usage is not populated"
  }

  # This detection is raised when a primitive element with O usage is populated
  # Template parameters are:
  # 1) Target element
  # 2) Element value
  # 2) (Optional) the context of this usage - for example when the usage is coming from a conditional
  o-usage {
    template = "Optional element %s was populated with the value %s.%s"
    category = ${report.category.o-usage}
    classification = ${report.classification.informational}
    documentation = "This detection is raised when a primitive element with O usage is populated"
  }

  # This detection is raised when a complex element with O usage is populated
  # Template parameters are:
  # 1) Target element
  # 2) (Optional) the context of this usage - for example when the usage is coming from a conditional
  o-usage-complex {
    template = "Optional element %s was populated.%s"
    category = ${report.category.o-usage}
    classification = ${report.classification.informational}
    documentation = "This detection is raised when a complex element with O usage is populated"
  }

  # This detection is raised when the number of repetitions of an element is not in the specified cardinality range
  # Template parameters are:
  # 1) Target element
  # 2) Minimum cardinality
  # 3) Maximum cardinality
  # 4) Number of repetitions found
  cardinality {
    template = "%s must be in the cardinality range of [%s, %s]; %s occurrences found"
    category = ${report.category.cardinality}
    classification = ${report.classification.error}
    documentation = "This detection is raised when the number of repetitions of an element is not in the specified cardinality range"
  }

  # This detection is raised when a null field has more than one repetition.
  # Template parameters are:
  # 1) Target element
  # 2) Number of repetitions found
  null-cardinality {
    template = "%s has a null value and more than one occurrence; %s occurrences found"
    category = ${report.category.cardinality}
    classification = ${report.classification.error}
    documentation = "This detection is raised when a null field has more than one repetition"
  }

  # This detection is raised when the value of a primitive element is not equal to the constant value defined in the profile
  # Template parameters are:
  # 1) Target element
  # 2) Expected constant value
  # 3) Found value
  constant-value {
    template = "The value of %s must be '%s' but '%s' was found"
    category = ${report.category.constant-value}
    classification = ${report.classification.error}
    documentation = "This detection is raised when the value of a primitive element is not equal to the constant value defined in the profile"
  }

  # (Specification Error) This detection is raised when a complex element has a constant value definition
  # Template parameters are:
  # 1) Target element
  # 2) Expected constant value
  constant-value-spec-error {
    template = "%s has a constant value definition of '%s' but is a complex data element"
    category = ${report.category.constant-value-spec-error}
    classification = ${report.classification.spec-error}
    documentation = "(Specification Error) This detection is raised when a complex element has a constant value definition"
  }

  # This detection is raised when the length of a primitive element is not in the specified length range.
  # Template parameters are:
  # 1) Target element
  # 2) Minimum length
  # 3) Maximum length
  # 4) Value of the element
  length {
    template = "The length of %s must be within the range [%s, %s]. Value = '%s'"
    category = ${report.category.length}
    classification = ${report.classification.warning}
    documentation = "This detection is raised when the length of a primitive element is not in the specified length range."
  }

  # This detection is raised when no length specification was provided for a primitive element
  # Template parameters are:
  # 1) Target element
  length-spec-error-no-valid {
    template = "No valid length specification was found for element %s"
    category = ${report.category.length-spec-error}
    classification = ${report.classification.spec-error}
    documentation = "This detection is raised when no length specification was provided for a primitive element"
  }

  # This detection is raised when both length and conf length are specified for an element
  # Template parameters are:
  # 1) Target element
  length-spec-error-xor {
    template = "Length specification error for element %s. One of (MaxLength, MinLength) or ConfLength should be present, but not both"
    category = ${report.category.length-spec-error}
    classification = ${report.classification.spec-error}
    documentation = "This detection is raised when both length and conf length are specified for an element"
  }

  # This detection is raised when the value of a primitive element is not valid according to the format expected from the data type.
  # Template parameters are:
  # 1) The error message is dynamically provided and derived from the format expected by datatype (E.g. NM datatype receiving a non-numeric value)
  format {
    template = "%s"
    category = ${report.category.format}
    classification = ${report.classification.error}
    documentation = "This detection is raised when the value of a primitive element is not valid according to the format expected from the data type"
  }

  # This detection is raised when a complex element has extra children non defined in the profile
  # Template parameters are:
  # 1) Target element
  extra {
    template = "%s has extra children"
    category = ${report.category.extra}
    classification = ${report.classification.error}
    documentation = "This detection is raised when a complex element has extra children non defined in the profile"
  }

  # This detection is raised when a primitive element contains unescaped separators
  # Template parameters are:
  # 1) Target element
  unescaped {
    template = "The primitive %s contains at least one unescaped delimiter"
    category = ${report.category.unescaped}
    classification = ${report.classification.error}
    documentation = "This detection is raised when a primitive element contains unescaped separators"
  }

  # This detection is raised when a segment is found at an unexpected location
  # Template parameters are:
  # 1) The content of the unexpected segment
  unexpected {
    template = "Segment %s is not expected at this location"
    category = ${report.category.unexpected}
    classification = ${report.classification.error}
    documentation = "This detection is raised when a segment is found at an unexpected location"
  }

  # This detection is raised when a segment definition is invalid (e.g. more than 3 letters segment id)
  # Template parameters are:
  # 1) The content of the invalid segment
  invalid {
    template = "'%s' is not a valid segment definition"
    category = ${report.category.invalid}
    classification = ${report.classification.error}
    documentation = "This detection is raised when a segment definition is invalid (e.g. more than 3 letters segment id)"
  }

  # This detection is raised when a field which has a dynamic mapping definition did not match any dynamic mapping flavor
  # Template parameters are:
  # 1) Reference value 1
  # 2) Reference value 2
  # 3) Target element
  unresolved-field {
  	template = "The values ('%s','%s') were not found in Dynamic Mapping for %s"
    category = ${report.category.unresolved-field}
    classification = ${report.classification.error}
    documentation = "This detection is raised when a field which has a dynamic mapping definition did not match any dynamic mapping flavor"
  }

  # This detection is raised to inform the user about the flavor selected after evaluation of dynamic mapping
  # Template parameters are:
  # 1) Target Element
  # 2) Selected Flavor
  # 3) Reference value for the mapping
  dynamic-mapping-match {
    template = "%s was mapped dynamically to datatype '%s' based on reference values %s"
    category = ${report.category.dynamic-mapping-match}
    classification = ${report.classification.informational}
    documentation = "This detection is raised to inform the user about the flavor selected after evaluation of dynamic mapping"
  }

  ##########################################################################################################
  ###                                       Content based detections                                     ###
  ##########################################################################################################

  # (legacy) This detection is raised when a (legacy) co-constraint fails
  # Template parameters are
  # 1) If condition
  # 2) Then assertions
  coconstraint-failure {
    template = "If %s then %s %s"
    category = ${report.category.coconstraint-failure}
    classification = ${report.classification.error}
    documentation = "(legacy) This detection is raised when a (legacy) co-constraint fails"
  }

  # (legacy) This detection is raised when a (legacy) co-constraint succeeds
  # Template parameters are
  # 1) If condition
  # 2) Then assertions
  coconstraint-success {
    template = "If %s then %s"
    category = ${report.category.coconstraint-success}
    classification = ${report.classification.affirmative}
    documentation = "(legacy) This detection is raised when a (legacy) co-constraint succeeds"
  }

  # This detection is raised when an order indifferent trigger condition does not match any element
  # The error message is provided in the trigger definition
  highlevel-content {
    	category = "High-level Content Error"
    	classification = ${report.classification.error}
    	documentation = "This detection is raised when an order indifferent trigger condition does not match any element"
  }

  # This detection is raised when a defined constraint fails (e.g. conformance statement)
  # The classification of this detection is dependent on the "Strength" attribute of the constraint
  # Template parameters are
  # 1) Constraint ID
  # 2) Constraint assertion description
  constraint-failure {
    template = "%s - %s"
    category = ${report.category.constraint-failure}
    classification = ${report.classification.error}
    documentation = "This detection is raised when a defined constraint fails (e.g. conformance statement) - the classification of this detection is dependent on the Strength attribute of the constraint"
    strength {
       shall = ${report.classification.error}
       should = ${report.classification.warning}
    }
  }

  # This detection is raised when a constraint succeeds (e.g. conformance statement)
  # Template parameters are
  # 1) Constraint ID
  # 2) Constraint assertion description
  constraint-success {
    template = "%s - %s"
    category = ${report.category.constraint-success}
    classification = ${report.classification.affirmative}
    documentation = "This detection is raised when a constraint succeeds (e.g. conformance statement)"
  }

  # (Specification Error) This detection is raised when a constraint (e.g. conformance statement) evaluation was inconclusive
  # Template parameters are
  # 1) Constraint ID
  # 2) Constraint assertion description
  constraint-spec-error {
    template = "%s - %s"
    category = ${report.category.constraint-spec-error}
    classification = ${report.classification.spec-error}
    documentation = "(Specification Error) This detection is raised when a constraint (e.g. conformance statement) evaluation was inconclusive"
  }

  # This detection is raised when a content constraint fails - applies to test defined constraints
  # The classification of this detection is dependent on the "Strength" attribute of the constraint
  # Template parameters are
  # 1) Constraint ID
  # 2) Constraint assertion description (when test data specification is test case fixed or test case fixed list the error message is dynamically generated)
  content-failure {
    template = "%s - %s"
    category = ${report.category.content-failure}
    classification = ${report.classification.error}
    documentation = "This detection is raised when a content constraint fails - applies to test defined constraints. The classification of this detection is dependent on the Strength attribute of the constraint"
    strength {
       shall = ${report.classification.error}
       should = ${report.classification.warning}
    }
  }

  # This detection is raised when a content constraint succeeds - applies to test defined constraints
  # Template parameters are
  # 1) Constraint ID
  # 2) Constraint assertion description
  content-success {
    template = "%s - %s"
    category = ${report.category.content-success}
    classification = ${report.classification.affirmative}
    documentation = "This detection is raised when a content constraint succeeds - applies to test defined constraints"
  }

  # (Specification Error) This detection is raised when a content constraint was inconclusive - applies to test defined constraints
  # Template parameters are
  # 1) Constraint ID
  # 2) Constraint assertion description
  content-spec-error {
    template = "%s - %s"
    category = ${report.category.content-spec-error}
    classification = ${report.classification.spec-error}
    documentation = "(Specification Error) This detection is raised when a content constraint was inconclusive - applies to test defined constraints"
  }

  # This detection is raised when conditional usage evaluation is successful
  # Template parameters are
  # 1) The predicate serialized to string "Predicate C(%s/%s) target: %s description: %s"
  predicate-success {
    template = "%s"
    category = ${report.category.predicate-success}
    classification = ${report.classification.affirmative}
    documentation = "This detection is raised when conditional usage evaluation is successful"
  }

  # This detection is raised when conditional usage evaluation fails
  # Template parameters are
  # 1) The usage error message
  # 2) The effective usage selected after predicate evaluation
  # 3) The condition predicate description
  predicate-failure {
    template = "%s. The element is %s based on the condition predicate evaluation: %s"
    category = ${report.category.predicate-failure}
    classification = ${report.classification.error}
    documentation = "This detection is raised when conditional usage evaluation fails"
  }

  # (Specification Error) This detection is raised when conditional usage evaluation is inconclusive due to a specification error
  # Template parameters are
  # 1) The predicate serialized to string "Predicate C(%s/%s) target: %s description: %s"
  predicate-spec-error {
    template = "%s"
    category = ${report.category.predicate-spec-error}
    classification = ${report.classification.spec-error}
    documentation = "(Specification Error) This detection is raised when conditional usage evaluation is inconclusive due to a specification error"
  }

  # This detection is raised to inform the user about the usage selected after evaluation of a condition predicate
  # Template parameters are:
  # 1) Selected usage
  # 2) Target element
  # 3) Predicate True Usage
  # 4) Predicate False Usage
  # 5) Predicate condition
  # 6) Result of condition evaluation True/False
  predicate-usage-selection {
    template = "Usage %s was selected for %s with conditional usage C(%s/%s) and predicate '%s'. Condition evaluated to '%s'"
    category = ${report.category.predicate-usage-selection}
    classification = ${report.classification.informational}
    documentation = "This detection is raised to inform the user about the usage selected after evaluation of a condition predicate"
  }

    # This detection is raised to inform the user that a target path for a predicate has been changed from having specific instance numbers to * to match all repetitions
    # Template parameters are:
    # 1) Target element
    # 2) Element Path Specified
    # 3) Element Path Changed
  predicate-path-occurrence {
    template = "Usage predicate for %s was defined with a target element path '%s' that has specific occurrence numbers, the path was generalized to '%s' which includes all occurrences as this was likely a mistake"
    category = ${report.category.predicate-path-occurrence}
    classification = ${report.classification.informational}
    documentation = "This detection is raised to inform the user that a target path for a predicate has been changed from having specific instance numbers to * to match all repetitions"
  }

  ##################################################################################################
  ###                                   Value set based detections                               ###
  ##################################################################################################

  # This detection is raised when a code used in the message is in the value set but has no usage defined
  # Template parameters are
  # 1) The code value
  # 2) Target element
  # 3) Value set where the code was found
  # 4) (Optional) if the code was matched from a code pattern, this would be the pattern it matched
  no-code-usage {
    template = "The value '%s' at location %s has no code usage in Value Set: %s%s"
    category = ${report.category.no-code-usage}
    classification = ${report.classification.alert}
    documentation = "This detection is raised when a code used in the message is in the value set but has no usage defined"
  }

  # This detection is raised when a code used in the message is in the value set with usage E
  # Template parameters are
  # 1) The code value
  # 2) Target element
  # 3) Value set where the code was found
  # 4) (Optional) if the code was matched from a code pattern, this would be the pattern it matched
  evs {
    template = "The value '%s' at location %s is an excluded (E) code; Value Set: %s%s"
    category = ${report.category.evs}
    classification = ${report.classification.error}
    documentation = "This detection is raised when a code used in the message is in the value set with usage E"
    overrides {

      suggested {
        default {
          classification = ${report.classification.alert}
        }
      }

      undetermined {
        default {
          classification = ${report.classification.alert}
        }
      }

    }
  }

  # This detection is raised when a code used in the message is in the value set with usage P
  # Template parameters are
  # 1) The code value
  # 2) Target element
  # 3) Value set where the code was found
  # 4) (Optional) if the code was matched from a code pattern, this would be the pattern it matched
  pvs {
    template = "The value '%s' at location %s is a permitted (P) code; Value Set: %s%s"
    category = ${report.category.pvs}
    classification = ${report.classification.alert}
    documentation = "This detection is raised when a code used in the message is in the value set with usage P"
  }

  # This detection is raised when a code used in the message is in the value set with usage R
  # Template parameters are
  # 1) The code value
  # 2) Target element
  # 3) Value set where the code was found
  # 4) (Optional) if the code was matched from a code pattern, this would be the pattern it matched
  rvs {
    template = "The value '%s' at location %s is a required (R) code; Value Set: %s%s"
    category = ${report.category.rvs}
    classification = ${report.classification.affirmative}
    documentation = "This detection is raised when a code used in the message is in the value set with usage R"

    overrides {

      suggested {
        default {
          classification = ${report.classification.alert}
          template = "The value '%s' at location %s is a required (R) code; Value Set: %s%s. Note: Since the Binding Strength of the code set is Suggested (S), the “R” code usage is of no consequence."
        }
      }

      undetermined {
        default {
          classification = ${report.classification.alert}
        }
      }

    }
  }

  # This detection is raised when a value set in the value set library matches the name .*0396.*
  # and contains either codes HL7nnnn or 99zzz without a CodePattern attribute and feature flag legacy0396 is active
  # The purpose is to inform users that legacy behavior for handling value set HL70396 is active
  legacy-0396 {
    template = "The value set library contains value sets matching the name .*0396.* and containing the value ['HL7nnnn' | '99zzz'] defined as a code, instead of a pattern. To maintain compatibility with legacy profiles, those codes will be interpreted as patterns. It is highly recommended to modify the profile to define them as patterns instead of codes. For example,  for the pattern 'HL7nnnn' add the CodePattern=\"HL7[0-9]{4}\" to the value set  or alternatively explicitly replace the value HL7nnnn with the supported HL7 table names e.g., HL70001, HL70005, etc."
    category = ${report.category.vs-0396}
    classification = ${report.classification.informational}
    documentation = "This detection is raised when a value set in the value set library matches the name .*0396.* and contains either codes HL7nnnn or 99zzz without a CodePattern attribute and feature flag legacy0396 is active. The purpose is to inform users that legacy behavior for handling value set HL70396 is active"
  }

  # This detection is raised when a binding of an element in the message has U binding strength
  # Template parameters are
  # 1) Value Sets in the binding
  # 2) Target element
  ubs {
    template = "A binding with value sets %s at location '%s' has Undetermined binding strength"
    category = ${report.category.ubs}
    classification = ${report.classification.alert}
    documentation = "This detection is raised when a binding of an element in the message has U binding strength"
  }

  # (Specification Error) This detection is raised when a code in the message is found multiple times in value sets in the binding - applies to primitive elements
  # Either code is duplicate in the same value set or code is found across multiple value sets in the binding
  # Template parameters are
  # 1) The code value
  # 2) Target element
  # 3) Value sets where the code was found
  duplicate-code {
    template = "Multiple occurrences of the value '%s' at location %s where found in Value Sets: %s"
    category = ${report.category.duplicate-code}
    classification = ${report.classification.spec-error}
    documentation = "(Specification Error) This detection is raised when a code in the message is found multiple times in value sets in the binding - applies to primitive elements. Either code is duplicate in the same value set or code is found across multiple value sets in the binding"
  }

  # (Specification Error) This detection is raised when a code and code system in the message is found multiple times in value sets in the binding - applies to coded elements
  # Either code is duplicate in the same value set or code is found across multiple value sets in the binding
  # Template parameters are
  # 1) The code value
  # 2) Code system
  # 3) Target element
  # 4) Value sets where the code was found
  duplicate-code-codesystem {
    template = "Multiple occurrences of the code '%s' and code system %s at location %s where found in Value Sets: %s"
    category = ${report.category.duplicate-code}
    classification = ${report.classification.spec-error}
    documentation = "(Specification Error) This detection is raised when a code and code system in the message is found multiple times in value sets in the binding - applies to coded elements. Either code is duplicate in the same value set or code is found across multiple value sets in the binding"
  }

  # (Specification Error) This detection is raised when a primitive element has a binding with multiple value sets
  # Template parameters are
  # 1) Value sets in the binding
  # 2) Target element
  multi-vs-simple {
    template = "A binding with multiple value sets %s was defined for primitive element at location '%s'"
    category = ${report.category.vs-spec-error}
    classification = ${report.classification.spec-error}
    documentation = "(Specification Error) This detection is raised when a primitive element has a binding with multiple value sets"
  }

  # This detection is raised when a code in the message cannot be found in the value set - applies to primitive elements
  # Template parameters are
  # 1) Value of the element
  # 2) Target element
  # 3) Value set in the binding
  code-not-found-simple {
    template = "The value '%s' at location %s is not member of the value set %s"
    category = ${report.category.code-not-found}
    classification = ${report.classification.alert}
    documentation = "This detection is raised when a code in the message cannot be found in the value set - applies to primitive elements"

    overrides {
      required {
        default  {
           classification = ${report.classification.error}
        }	  
        open {
          default  {
            template = "The value '%s' at location %s is not member of the value set %s. The value set is an open value set. Validation can only be performed against a snapshot of an open value set. The snapshot may be different from the current version of the value set."
          }
        }
        closed {
          dynamic {
            template = "The value '%s' at location %s is not member of the value set %s. The value set is a dynamic value set. Validation can only be performed against a snapshot of a dynamic value set. The snapshot may be different from the current version of the value set."
          }
        }
        no-value {
          dynamic {
            template = "The value '%s' at location %s is not member of the value set %s. The value set is a dynamic value set. Validation can only be performed against a snapshot of a dynamic value set. The snapshot may be different from the current version of the value set."
          }
        }
      }
    }
  }

  # This detection is raised when a code in the message cannot be found in the value set - applies to coded elements
  # Template parameters are
  # 1) Value of the element at the code location
  # 2) Value of the element at the code system location
  # 3) Target element
  # 4) Value set in the binding
  code-not-found-coded-element {
    template = "The code '%s' and code system '%s' at location %s is not member of the value set %s"
    category = ${report.category.code-not-found}
    classification = ${report.classification.alert}
    documentation = "This detection is raised when a code in the message cannot be found in the value set - applies to coded elements"

    overrides {
      required {
        default  {
           classification = ${report.classification.error}
        }	  
        open {
          default  {
            template = "The code '%s' and code system '%s' at location %s is not member of the value set %s. The binding contains an open value set. Validation can only be performed against a snapshot of an open value set. The snapshot may be different from the current version of the value set."
          }
        }
        closed {
          dynamic {
            template = "The code '%s' and code system '%s' at location %s is not member of the value set %s. The binding contains a dynamic value set. Validation can only be performed against a snapshot of a dynamic value set. The snapshot may be different from the current version of the value set."
          }
        }
        no-value {
          dynamic {
            template = "The code '%s' and code system '%s' at location %s is not member of the value set %s. The binding contains a dynamic value set. Validation can only be performed against a snapshot of a dynamic value set. The snapshot may be different from the current version of the value set."
          }
        }
      }
    }
  }

  # This detection is raised when a code in the message matches a code in the value set but not the code system - applies to coded elements
  # Template parameters are
  # 1) Value of the element at the code location
  # 2) Value of the element at the code system location
  # 3) Target element
  # 4) Value set in the binding
  # 5) Code system in the value set
  code-not-found-cs {
    template = "The value ('%s', '%s') at location %s is not member of the value set %s, expected code system '%s'"
    category = ${report.category.code-not-found}
    classification = ${report.classification.alert}
    documentation = "This detection is raised when a code in the message matches a code in the value set but not the code system - applies to coded elements"

    overrides {
      required {
        default  {
           classification = ${report.classification.error}
        }	  
        open {
          default  {
            template = "The value ('%s', '%s') at location %s is not member of the value set %s, expected code system '%s'. The binding contains an open value set. Validation can only be performed against a snapshot of an open value set. The snapshot may be different from the current version of the value set."
          }
        }
        closed {
          dynamic {
            template = "The value ('%s', '%s') at location %s is not member of the value set %s, expected code system '%s'. The binding contains a dynamic value set. Validation can only be performed against a snapshot of a dynamic value set. The snapshot may be different from the current version of the value set."
          }
        }
        no-value {
          dynamic {
            template = "The value ('%s', '%s') at location %s is not member of the value set %s, expected code system '%s'. The binding contains a dynamic value set. Validation can only be performed against a snapshot of a dynamic value set. The snapshot may be different from the current version of the value set."
          }
        }
      }
    }
  }

  # This detection is raised when the code matches the code system element was not populated in the message - applies to coded elements
  # Template parameters are
  # 1) Value of the element at the code location
  # 2) Target element
  # 3) Value set in the binding
  # 4) Code system in the value set
  # 5) Location of the code system
  code-not-found-cs-empty {
    template = "The value '%s' at location %s was found in the value set %s associated with code system '%s', but code system was not populated in the message at location %s. The validation engine can not determine if the expected code was used."
    category = ${report.category.code-not-found}
    classification = ${report.classification.error}
    documentation = "This detection is raised when the code matches the code system element was not populated in the message - applies to coded elements"
  }

  # (Specification Error) This detection is raised when a value set referenced in an element's value set binding is not found in the value set library
  # Template parameters are
  # 1) The value set reference that is not found
  # 2) Target element
  vs-not-found-binding {
    template = "The value set '%s' specified for binding at location %s cannot be found."
    category = ${report.category.vs-not-found}
    classification = ${report.classification.spec-error}
    documentation = "(Specification Error) This detection is raised when a value set referenced in an element's value set binding is not found in the value set library"
  }

  # This detection is raised when a value set referenced in an element's value set binding is empty
  # Template parameters are
  # 1) The value set
  empty-vs {
    template = "The value set %s is empty"
    category = ${report.category.empty-vs}
    classification = ${report.classification.alert}
    documentation = "This detection is raised when a value set referenced in an element's value set binding is empty"
  }

  # This detection is raised when a code is not found for each dynamic value set in the binding
  # Template parameters are
  # 1) The dynamic value set
  # 2) The location of the binding
  dynamic-vs {
    template = "The value set %s bound at location %s has as dynamic stability. Validation can only be performed against a snapshot of a dynamic value set. The snapshot may be different from the current version of the value set."
    category = ${report.category.dynamic-vs}
    classification = ${report.classification.alert}
    documentation = "This detection is raised when a code is not found for each dynamic value set in the binding"
  }

  # (Specification Error) This detection is raised when a binding location (code location or code system location) is not valid
  # Either the location doesn't exist in the profile or it matches more than one element
  # Template parameters are
  # 1) The binding location error message
  binding-location {
    template = "%s"
    category = ${report.category.binding-location}
    classification = ${report.classification.spec-error}
    documentation = "(Specification Error) This detection is raised when a binding location (code location or code system location) is not valid"
  }

  # This detection is raised when the value set used in a binding is marked as excluded from validation
  # Template parameters are
  # 1) The excluded value set
  vs-no-validation {
    template = "The value set %s has been excluded from the validation"
    category = ${report.category.vs-no-validation}
    classification = ${report.classification.informational}
    documentation = "This detection is raised when the value set used in a binding is marked as excluded from validation"
  }

  # This detection is raised when a coded element with multiple binding locations (e.g. 1 or 4), has codes at multiple locations coming from the same value set
  # Template parameters are
  # 1) The locations where the codes are
  # 2) The value set where the codes were found
  coded-element-xor {
    template = "Elements %s are all valued from the same value set %s"
    category = ${report.category.coded-element-xor}
    classification = ${report.classification.error}
    documentation = "This detection is raised when a coded element with multiple binding locations (e.g. 1 or 4), has codes at multiple locations coming from the same value set"

    overrides {
	  undetermined {
        default  {
          classification = ${report.classification.alert}
        }
      }
      suggested {
        default  {
          classification = ${report.classification.alert}
        }
      }
    }
  }

  # This detection is raised when a value set in the value set library is external
  # and the validation engine configuration has disabled validation of external value sets
  # either explicitly or by not providing an HTTP Client instance
  external-valueset-validation-disabled {
      template = "The value set library contains external value sets, but external value set validation is disabled."
      category = ${report.category.external-valueset-validation-disabled}
      classification = ${report.classification.informational}
      documentation = "This detection is raised when a value set in the value set library is external and the validation engine configuration has disabled validation of external value sets either explicitly or by not providing an HTTP Client instance"
  }

  # This detection is raised when external value set validation failed due to an invalid response or network error
  # Template parameters are
  # 1) The code value to validate
  # 2) Target element
  # 3) The external value set
  # 4) The external value set url
  # 5) The error
  external-vs-spec-error {
    template = "Could not validate code '%s' at location %s, using external value set '%s' at url '%s' due to: %s"
    category = ${report.category.external-vs-spec-error}
    classification = ${report.classification.warning}
    documentation = "This detection is raised when external value set validation failed due to an invalid response or network error"
  }

  # This detection is raised when a value set has a programmatically defined proxy that modifies its behavior
  # 1) The target element of the binding
  # 2) The value set's binding identifier
  proxied-valueset {
    template = "%s has a value set binding referencing value set %s. This value set has been proxied to modify its behavior, the validation might not reflect the exact content of this value set."
    category = ${report.category.proxied-valueset}
    classification = ${report.classification.informational}
    documentation = "This detection is raised when a value set has a programmatically defined proxy that modifies its behavior"
  }

  ##################################################################################################
  ###                               Single Code based detections                                 ###
  ##################################################################################################


  # This detection is raised when a single code bound to a coded element at multiple possible locations is found in more than one location
  # Template parameters are
  # 1) Expected Code
  # 2) Expected Code System
  # 3) Locations Found
  # 4) Coded Element path
  single-code-xor {
    template = "Code '%s' from code system '%s' was found at multiple locations %s within the coded element %s. Code must be used at only one location."
    category = ${report.category.single-code-failure}
    classification = ${report.classification.error}
    documentation = "This detection is raised when a single code bound to a coded element at multiple possible locations is found in more than one location"
  }

  # This detection is raised when a single code bound to a coded element matches the code but not the code system
  # Template parameters are
  # 1) Expected Code
  # 2) Expected Code System
  # 3) Location where code was Found
  # 4) Found Code System
  # 5) Code System Location
  # 6) Expected Code System
  single-code-cs-invalid {
    template = "Code '%s' from code system '%s' was not found in location %s; Code System Value '%s' found at %s doesn't match expected '%s'"
    category = ${report.category.single-code-failure}
    classification = ${report.classification.error}
    documentation = "This detection is raised when a single code bound to a coded element matches the code but not the code system"
  }

  # This detection is raised when a single code bound to a coded element matches the code but the code system is not populated
  # Template parameters are
  # 1) Expected Code
  # 2) Expected Code System
  # 3) Location where Code Match Found
  # 4) Location where Code System was expected
  single-code-cs-not-found {
    template = "Code '%s' from code system '%s' was not found in location %s; Code System expected but was not populated at location %s"
    category = ${report.category.single-code-failure}
    classification = ${report.classification.error}
    documentation = "This detection is raised when a single code bound to a coded element matches the code but the code system is not populated"
  }

  # This detection is raised when a single code bound to a location was not found in the message
  # Template parameters are
  # 1) Expected Code
  # 2) Expected Code System
  # 3) Found Code
  # 4) Found Code Location
  # 5) Expected Code
  single-code-not-found {
    template = "Code '%s' from code system '%s' was not found; Code Value '%s' found at %s doesn't match expected '%s'"
    category = ${report.category.single-code-failure}
    classification = ${report.classification.error}
    documentation = "This detection is raised when a single code bound to a location was not found in the message"
  }

  # This detection is raised when a single code binding requirement was satisfied
  # Template parameters are
  # 1) Expected Code
  # 2) Expected Code System
  # 3) Found Code Location
  single-code-success {
    template = "Code '%s' from code system '%s' was found at %s"
    category = ${report.category.single-code-success}
    classification = ${report.classification.affirmative}
    documentation = "This detection is raised when a single code binding requirement was satisfied"
  }

  ##################################################################################################
  ###                                    Slicing based detections                                ###
  ##################################################################################################


  # This detection is raised when a slice has been matched to an occurrence based on an assertion
  # Template parameters are:
  # 1) Assertion Description
  # 2) Target element
  # 3) Type of resource applied (e.g. Segment, Datatype)
  # 4) Name of applied resource
  assertion-slicing-match {
    template = "A slice with condition '%s' was matched for element %s, %s %s is applied"
    category = ${report.category.slicing}
    classification = ${report.classification.informational}
    documentation = "This detection is raised when a slice has been matched to an occurrence based on an assertion"
  }

  # This detection is raised when a slice has been matched to an occurrence based on occurrence number
  # Template parameters are:
  # 1) Occurrence number
  # 2) Target element
  # 3) Type of resource applied (e.g. Segment, Datatype)
  # 4) Name of applied resource
  occurrence-slicing-match {
    template = "A slice for occurrence number %s was matched for element %s, %s %s is applied"
    category = ${report.category.slicing}
    classification = ${report.classification.informational}
    documentation = "This detection is raised when a slice has been matched to an occurrence based on occurrence number"
  }

  # This detection is raised when an element has slicing defined but no slice is matched
  # Template parameters are:
  # 1) Target element
  # 2) Default Flavor Used
  slicing-no-match {
    template = "Slicing was defined for element %s but not slice matched, default flavor used %s"
    category = ${report.category.slicing}
    classification = ${report.classification.informational}
    documentation = "This detection is raised when an element has slicing defined but no slice is matched"
  }

  # (Specification Error) This detection is raised when the evaluation of an assertion based slice condition is inconclusive
  # Template parameters are:
  # 1) Condition Assertion Description
  # 2) Type of resource to be applied (e.g. Segment, Datatype)
  # 3) Name of resource to be applied
  # 4) Target element
  # 5) Reason why it's inconclusive
  assertion-slicing-inconclusive {
      template = "Slice with condition '%s' and target reference of %s %s could not be evaluated for element %s, due to : %s"
      category = ${report.category.slicing-spec-error}
      classification = ${report.classification.spec-error}
      documentation = "(Specification Error) This detection is raised when the evaluation of an assertion based slice condition is inconclusive"
  }

  # (Specification Error) This detection is raised when the target of a message level segment slicing is a group instead of segment
  # Template parameters are:
  # 1) Target element
  slicing-target-group {
    template = "Segment slicing was defined for element %s, the target of segment slicing should be a segment"
    category = ${report.category.slicing-spec-error}
    classification = ${report.classification.spec-error}
    documentation = "(Specification Error) This detection is raised when the target of a message level segment slicing is a group instead of segment"
  }

  # (Specification Error) This detection is raised when applying the matched flavor from a slicing fails
  # Template parameters are
  # 1) Type of resource to be applied (e.g. Segment, Datatype)
  # 2) Name of resource to be applied
  # 3) Target element for the slicing
  # 4) Reason for failure
  slicing-match-error {
    template = "Slice with target reference of %s %s matched for element %s could not be applied due to : %s"
    category = ${report.category.slicing-spec-error}
    classification = ${report.classification.spec-error}
    documentation = "(Specification Error) This detection is raised when applying the matched flavor from a slicing fails"
  }

  ##################################################################################################
  ###                             Co-Constraints based detections                                ###
  ##################################################################################################

  # This detection is raised when a required co-constraint is not matched
  # Template parameters are
  # 1) (Optional) Group Instance Description - if co-constraint was defined in a group
  # 2) Co-Constraint Description
  required-co-constraint {
    template = "%sThe co-constraint defined as %s is required but was not found"
    category = ${report.category.co-constraint}
    classification = ${report.classification.error}
    documentation = "This detection is raised when a required co-constraint is not matched"
  }

  # This detection is raised when a required co-constraint group is not found (when its primary co-constraint is not matched)
  # Template parameters are
  # 1) Group Name
  # 2) Primary Co-Constraint Description
  required-group {
    template = "The co-constraint group '%s' is required but was not found. REASON : the primary co-constraint of %s defined as: %s, was not found. Secondary co-constraints of a group are not evaluated when the primary co-constraint is not found in the message."
    category = ${report.category.co-constraint}
    classification = ${report.classification.error}
    documentation = "This detection is raised when a required co-constraint group is not found (when its primary co-constraint is not matched)"
  }

  # This detection is raised when a co-constraint cardinality requirement is not satisfied
  # Template parameters are
  # 1) (Optional) Group Instance Description - if co-constraint was defined in a group
  # 2) Co-Constraint Description
  # 3) Minimum cardinality
  # 4) Maximum cardinality
  # 4) Number of occurrences
  cardinality-co-constraint {
    template = "%sThe co-constraint defined as %s, must be in the cardinality range of [%s, %s] but %s occurrences found"
    category = ${report.category.co-constraint}
    classification = ${report.classification.error}
    documentation = "This detection is raised when a co-constraint cardinality requirement is not satisfied"
  }

  # This detection is raised when a co-constraint group cardinality requirement is not satisfied
  # Template parameters are
  # 1) Group Name
  # 2) Minimum cardinality
  # 3) Maximum cardinality
  # 4) Number of occurrences
  # 5) Grouper element and values for occurrences found
  cardinality-group {
    template = "The co-constraint group '%s' must be in the cardinality range of [%s, %s] but %s occurrences found.%s"
    category = ${report.category.co-constraint}
    classification = ${report.classification.error}
    documentation = "This detection is raised when a co-constraint group cardinality requirement is not satisfied"
  }

  # This detection is raised when a plaintext co-constraint cell evaluation fails
  # 1) (Optional) Group Instance Description
  # 2) Co-Constraint Description
  # 3) CoConstraint Cell (PlainText) description
  # 4) Value found
  cc-plain-text-failure {
    template = "%sThe co-constraint defined as %s failed to satisfy the constraint requirement: %s. REASON : Value '%s' was found."
    category = ${report.category.co-constraint}
    classification = ${report.classification.error}
    documentation = "This detection is raised when a plaintext co-constraint cell evaluation fails"
  }

  # This detection is raised when a code co-constraint cell evaluation fails because the code was not found
  # When locations are populated but code value does not match
  # 1) (Optional) Group Instance Description
  # 2) Co-Constraint Description
  # 3) CoConstraint Cell (Code) description
  # 4) Code Found
  # 5) Code Expected
  cc-code-failure {
    template = "%sThe co-constraint defined as %s failed to satisfy the constraint requirement: %s. REASON: Invalid code '%s'; '%s' was expected."
    category = ${report.category.co-constraint}
    classification = ${report.classification.error}
    documentation = "This detection is raised when a code co-constraint cell evaluation fails because the code was not found"
  }

  # This detection is raised when a code co-constraint cell evaluation fails because the code system was invalid
  # When code was found with a different code system
  # 1) (Optional) Group Instance Description
  # 2) Co-Constraint Description
  # 3) CoConstraint Cell (Code) description
  # 4) Code System Found
  # 5) Code System Expected
  cc-code-failure-invalid-codesys {
    template = "%sThe co-constraint defined as %s failed to satisfy the constraint requirement: %s. REASON: Invalid code system '%s' found; '%s' was expected."
    category = ${report.category.co-constraint}
    classification = ${report.classification.error}
    documentation = "This detection is raised when a code co-constraint cell evaluation fails because the code system was invalid"
  }

  # This detection is raised when a code co-constraint cell evaluation fails because the code system was not populated
  # When code was found but code system not populated
  # 1) (Optional) Group Instance Description
  # 2) Co-Constraint Description
  # 3) CoConstraint Cell (Code) description
  # 4) Code System Location
  cc-code-failure-notfound-codesys {
    template = "%sThe co-constraint defined as %s failed to satisfy the constraint requirement: %s. REASON: Code system not populated at location %s"
    category = ${report.category.co-constraint}
    classification = ${report.classification.error}
    documentation = "This detection is raised when a code co-constraint cell evaluation fails because the code system was not populated"
  }

  # This detection is raised when a value set co-constraint cell evaluation fails
  # When the codes at binding locations were not found in any ValueSet
  # This detections will be accompanied with other detections coming from the value set binding validation
  # 1) (Optional) Group Instance Description
  # 2) Co-Constraint Description
  # 3) CoConstraint ValueSet Binding description
  cc-vs-failure {
    template = "%sThe co-constraint defined as %s failed to satisfy the constraint requirement: %s."
    category = ${report.category.co-constraint}
    classification = ${report.classification.error}
    documentation = "This detection is raised when a value set co-constraint cell evaluation fails, when the codes at binding locations were not found in any Value Set. This detections will be accompanied with other detections coming from the value set binding validation"
  }

  # This detection is raised when a co-constraint cell evaluation succeeds
  # 1) (Optional) Group Instance Description
  # 2) Co-Constraint Description
  # 3) CoConstraint Cell description
  cc-success {
    template = "%sThe co-constraint defined as %s satisfied constraint : %s"
    category = ${report.category.co-constraint}
    classification = ${report.classification.affirmative}
    documentation = "This detection is raised when a co-constraint cell evaluation succeeds"
  }

  # (Specification error) This detection is raised when a co-constraint cell evaluation could not be done
  # because of an issue related to the specification (e.g invalid path)
  # 1) CoConstraint Cell description
  # 2) Location where it was evaluated from
  # 3) Reason why it could not be conclusive
  cc-spec-error {
    template = "Evaluation of '%s' from context location %s was inconclusive due to error : %s"
    category = ${report.category.co-constraint-spec-error}
    classification = ${report.classification.spec-error}
    documentation = "(Specification error) This detection is raised when a co-constraint cell evaluation could not be done"
  }

  # (Specification error) This detection is raised when a value set co-constraint cell evaluation could not be done
  # because of an issue related to the specification of the binding
  # 1) CoConstraint Cell (Value Set) description
  # 2) Location where it was evaluated from
  cc-binding-spec-error {
    template = "Evaluation of '%s' from context location %s was inconclusive"
    category = ${report.category.co-constraint-spec-error}
    classification = ${report.classification.spec-error}
    documentation = "(Specification error) This detection is raised when a value set co-constraint cell evaluation could not be done because of an issue related to the specification of the binding"
  }

  # (Specification error) This detection is raised when the evaluation of the condition of a conditional co-constraint table
  # could not be done because of an issue related to the assertion specification
  # 1) Condition description
  cc-condition-spec-error {
    template = "CoConstraint table condition '%s' evaluation was inconclusive"
    category = ${report.category.co-constraint-spec-error}
    classification = ${report.classification.spec-error}
    documentation = "(Specification error) This detection is raised when the evaluation of the condition of a conditional co-constraint table could not be done because of an issue related to the assertion specification"
  }

  # (Specification error) This detection is raised when co-constraint target segment can't be resolved
  # 1) Target path
  # 3) Reason
  cc-target-spec-error {
    template = "Co-Constraint binding's target segment at path %s evaluation was inconclusive due to : %s"
    category = ${report.category.co-constraint-spec-error}
    classification = ${report.classification.spec-error}
    documentation = "(Specification error) This detection is raised when co-constraint target segment can't be resolved"
  }

  # (Specification error) This detection is raised when co-constraint binding context can't be resolved
  # 1) Target path
  # 3) Reason
  cc-context-spec-error {
    template = "Co-Constraint binding's target context at path %s evaluation was inconclusive due to : %s"
    category = ${report.category.co-constraint-spec-error}
    classification = ${report.classification.spec-error}
    documentation = "(Specification error) This detection is raised when co-constraint binding context can't be resolved"
  }

  # (Specification error) This detection is raised when the target of a co-constraint table is not a group or message
  # 1) Target path
  # 3) Specified target context
  # 4) Element at target path which is not a group or message
  cc-context-not-group-or-message {
    template = "Specified path %s for co-constraint on %s returned the element %s which is not a group or message"
    category = ${report.category.co-constraint-spec-error}
    classification = ${report.classification.spec-error}
    documentation = "(Specification error) This detection is raised when the target of a co-constraint table is not a group or message"
  }

  # (Specification error) This detection is raised when the target of a co-constraint table is not a segment
  # 1) Target path
  # 3) Specified target segment
  # 4) Element at target path which is not a segment
  cc-element-not-segment {
    template = "Specified path %s for co-constraint on %s returned the element %s which is not a segment"
    category = ${report.category.co-constraint-spec-error}
    classification = ${report.classification.spec-error}
    documentation = "(Specification error) This detection is raised when the target of a co-constraint table is not a segment"
  }

  # This detection is raised when an individual co-constraint doesn't have a unique value at the location of the group ID element
  # 1) CoConstraint description
  # 2) GroupId location
  # 3) GroupId value
  # 4) Context
  cc-grouper-not-distinct {
    template = "%s should have a distinct Id at location %s, value '%s' is not distinct within %s"
    category = ${report.category.co-constraint}
    classification = ${report.classification.error}
    documentation = "This detection is raised when an individual co-constraint doesn't have a unique value at the location of the group ID element"
  }

  # (Specification error) This detection is raised when the groupId evaluation for co-constraint table is inconclusive
  # 1) Target path
  # 3) Reason
  cc-grouper-spec-error {
    template = "Co-Constraint group ID at path %s evaluation was inconclusive due to : %s"
    category = ${report.category.co-constraint-spec-error}
    classification = ${report.classification.spec-error}
    documentation = "(Specification error) This detection is raised when the groupId evaluation for co-constraint table is inconclusive"
  }
}

co-constraint {
	# (1) Segment name, (2) Selectors
	description = "%s segment with the following condition requirements: %s"
  # connector of selectors
  connector = "and"

  group-instance = "In co-constraint group %s with %s valued as '%s' "

	plain-text {
    	# (1) Segment Path, (2) Expected Value
    	selector = "%s is valued %s (Case Sensitive)"
      # (1) Segment Path, (2) Expected Value
      constraint = "%s SHALL be valued %s (Case Sensitive)"
    }
    code {
      # (1) Locations, (2) Expected Code Value, (3) Expected Code System Value
      selector = "%s is valued '%s' from code system %s"
      # (1) Locations, (2) Expected Code Value, (3) Expected Code System Value
      constraint = "%s SHALL be valued %s from the code system '%s'"
    }
    value-set {
      # (1) Locations, (2) Value Set Bindings
    	selector = "%s is valued with a code from one of the value sets: %s"
      # (1) Locations, (2) Value Set Bindings
      constraint = "%s SHALL be valued with a code from one of the value sets: %s"
    }
}

context-based {
  value-test-case-fixed = "Invalid content (based on test case fixed data). The value '%s' at '%s' does not match the expected value '%s'."
  value-test-case-fixed-list = "Invalid content (based on test case fixed data). The value '%s' at '%s' does not match one of the expected values '%s'."
}
